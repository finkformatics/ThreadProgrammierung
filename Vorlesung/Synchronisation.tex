\chapter{Synchronisation}

\section{Signale}
\begin{description}
\item[Synchronisation (hier)] Dafür sorgen, dass gewisse Abläufe ausgeschlossen sind.\\
Auch: Koordination.
\item[Signal (auch: Handshake, Meldung, engl. notification)] Hinweis an einen anderen Thread, dass er weitermachen kann.
\end{description}

Analogie:
\begin{itemize}
	\item Startschuss beim Wettlauf
	\item Staffel beim Staffellauf
	\item Anschlusszug muss warten
	\item Becher vor Kaffeezulauf
\end{itemize}

Ein Signal kann durch eine Sperre implementiert werden: 
\begin{itemize}
	\item signalisieren (auch: melden) = freigeben
	\item warten = belegen
\end{itemize}
Das Signal soll garantieren, dass eine gewisse Reihenfolge eingehalten wird.\\
\\ % TODO: Einrücken
P1: S1;
	freigeben(l);
P2:	belegen(l);
	S2;\\
% TODO: Grafik 20160519_SynchronisationZeitstrahl einfügen
\\
l muss freigegeben worden sein, bevor es wieder belegt werden kann, also findet S1 vor S2 statt.\\
\\
Durch die Verwendung von Signalen schränkt man die Menge der Abläufe ein.\\
Nachteil: weniger Parallelität\\
Extremfall: Nur noch eine Reihenfolge möglich; der Ablauf wird seriell. Abgesehen vom Koordinationsaufwand zu einem seriellen Programm gleichwertig.

\section[Beispiel: Erzeuger/Verbraucher (1)]{Beispiel: Erzeuger/Verbraucher-Problem, 1. Version}
Erzeuger und Verbraucher sind Threads. Der Erzeuger erzeugt Datenblöcke. Der Verbraucher holt die Datenblöcke ab und verarbeitet sie.\\
Die erzeugten aber noch nicht verbrauchten Datenblöcke werden in einem Puffer (:= Warteschlange) zwischengespeichert.\\
\\
\textbf{1. Version}: 1 Erzeuger, 1 Verbraucher, Puffer für 1 Datenblock.\\
\\ % TODO: Pseudocode
Thread erz:
	Wiederhole
		herstellen(datenblock);
		einreihen(puffer, datenblock);
Thread verbr:
	Wiederhole
		abholen(puffer, datenblock);
		verarbeiten(datenblock);\\
\\
Prozedur einreihen(puffer, datenblock):
\begin{enumerate}
	\item belegen(leer);
	\item kopieren(datenblock, puffer); $\rightarrow$ kopiert Datenblock in Puffer
	\item freigeben(voll);
\end{enumerate}
Prozedur abholen(puffer, datenblock):
\begin{enumerate}
	\setcounter{enumi}{3}
	\item belegen(voll);
	\item kopieren(puffer, datenblock); $\rightarrow$ kopiert Puffer in Datenblock
\end{enumerate}
Hauptprogramm (HP):
\begin{enumerate}
	\item[] Sperre voll anlegen; $\rightarrow$ als belegt
	\item[] Sperre leer anlegen; $\rightarrow$ als belegt
	\item[] Threads erz und verbr anlegen und laufen lassen;
	\item[0.] freigeben(leer);
\end{enumerate}

\subsubsection*{Kausalitätsgraph:} % TODO: Grafik Kausalitätsgraph

Ereignis $ e_1 $ \emph{ist kausal für} Ereignis $ e_2 $ $ :\Leftrightarrow $ In jedem Ablauf gilt: Wenn $ e_2 $ stattfindet, dann hat $ e_1 $ vorher stattgefunden. Mit anderen Worten: $ e_2 $ kann erst stattfinden, wenn $ e_1 $ vorher stattgefunden hat.

% Pfeil
Programmreihenfolge
% Gestrichelter Pfeil
Reihenfolge erzwungen durch Signal

\subsubsection*{Petri-Netz:} % TODO: Grafik Petrinetz
Legende für Petri-Netz: Kreis Platz, Strich Transition, Punkt Token.\\
\\
Bipartiter Graph: Zwei Sorten von Knoten; Pfeile nur zwischen verschiedenen Knoten-Sorten.
% TODO: Wenn möglich, Petrinetz laufen lassen

\subsubsection*{Signaldiagramm}

% TODO Grafik Signaldiagramm

Verwendung der Sperren voll und leer bewirkt hier:
\begin{enumerate}
\item (2) und (5) werden als kritische Bereiche behandelt. 
\item (2) und (5) werden nur abwechselnd ausgeführt.
\end{enumerate}
zu 1: Gegenseitiger Ausschluss gilt. $ \neg $leer.frei $\lor$ $\neg$voll.frei ist Invariante.\\
zu 2: Folgt aus Programmreihenfolge und 1.

\section{Semaphore}

\begin{description}
\item[Semaphor] Datenstruktur l mit Zustand l.frei $ \in \mathbb{N_0} $ und Operationen "`belegen"' und "`freigeben"'.
\end{description}
Sperre ist Spezialfall mit l.frei $ \in \{0, 1\} $.\\
\\
belegen(l): Wartet bis l.frei > 0 und setzt dann l.frei auf l.frei - 1.\\
freigeben(l): setzt l.frei auf l.frei + 1.\\
\\
Zweck: l.frei verschiedene Kopien eines Betriebsmittels werden verwaltet.\\
\\
Zusammenhang zu Klammerausdrücken:\\
"`("' bedeutet "`freigeben(l)"'\\
"`)"' bedeutet "`belegen(l)"'\\
l.frei = Anzahl der noch offenen Klammern.\\
\\
Beispiel:          ( ( ) ( ) ) % TODO Zeitstrahl
%l.frei 2_|           _   _
%       1_|         _| |_| |_
%         |________|         |_______
%

\section[Beispiel: Erzeuger/Verbraucher (2)]{Beispiel: Erzeuger/Verbraucher-Problem, 2. Version}
2. Version: 1 Erzeuger, 1 Verbraucher, N Datenblöcke mit $ N > 0 $ beliebig.\\
\\
Threads erz und verbr wie in Version 1.\\
\\
Prozedur einreihen(puffer, datenblock):
\begin{enumerate}
\item belegen(nichtvoll);$ \rightarrow $ \textbf{I' gilt nun wieder}
\item stock(puffer, datenblock); $ \rightarrow $ Anfügen des Datenblocks an Puffer hinten
\item freigeben(nichtleer);$ \rightarrow $ \textbf{I gilt}
\end{enumerate}
Prozedur abholen(puffer, datenblock):
\begin{enumerate}
\setcounter{enumi}{3}
\item belegen(nichtleer); $\rightarrow$ \textbf{I' gilt}
\item datenblock := top(puffer); $ \rightarrow $ liefert vordersten Datenblock des Puffer
\item pop(puffer);
\item freigeben(nichtvoll); $\rightarrow$ \textbf{I gilt}
\end{enumerate}
Hauptprogramm:
\begin{itemize}
\item Leeren puffer anlegen
\item Semaphore nichtvoll und nichtleer erzeugen mit nichtvoll.frei = 0 und nichtleer.frei = 0.
\item Threads erz und verbr anlegen und laufen lassen.
\item freigeben$^N$(nichtvoll); $\rightarrow$ nichtvoll wird N-mal freigegeben. 
\item \textbf{I gilt}
\end{itemize}

Invariante I: $ 0 \leq \text{ nichtvoll.frei } \leq N \land \text{ nichtleer.frei } + \text{ nichtvoll.frei } \leq N $\\
Invariante I': $ 0 \leq \text{ nichtvoll.frei } \leq N \land \text{ nichtleer.frei } + \text{ nichtvoll.frei } \leq N - 1 $\\
Invariante I'': $ 0 \leq \text{ nichtvoll.frei } \leq N \land \text{ nichtleer.frei } + \text{ nichtvoll.frei } \leq N - 2 $\\
I'' gilt, wenn beide Threads belegen, aber noch nicht freigeben aufgerufen haben.

\section{Bedingte kritische Bereiche}
Ein kritischer Bereich soll nur betreten werden, wenn eine gewisse Bedingung B an die gemeinsame Variable gilt. Wie implementiert man das?
\begin{enumerate}
\item B vor dem Betreten des kritischen Bereichs überprüfen.\\Problem: B kann beim Betreten des kritischen Bereiches bereits wieder verletzt sein.
\item B im kritischen Bereich überprüfen.\\Problem: Solange B nicht gilt, soll der Thread warten. Weil er sich im kritischen Bereich befindet, können andere Threads die gemeinsame Variable nicht ändern und damit den Wert von B.
\end{enumerate}
Mit kritischen Bereichen kann man das Problem nicht lösen. Abhilfe: neues Konstrukt.

\section[Beispiel: Erzeuger/Verbraucher (3)]{Beispiel: Erzeuger/Verbraucher-Problem, 3. Version}

\section{Wiederbetretbare Sperren}

\section{Leser/Schreiber-Problem}