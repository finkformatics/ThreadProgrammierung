\documentclass[a4paper]{scrartcl}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\DeclareMathOperator{\anz}{anz}

\setlength\parindent{0pt}

\title{Übung zur Vorlesung Thread Programmierung}
\subtitle{Alle Programmieraufgaben sind auch im GitHub-Repository \url{https://github.com/lukaswerner/JavaConcurrency} zu finden.}
\date{}

\begin{document}
	
\maketitle

\section{Thread-Beispiele}

\subsection{Erzeugen von Threads in Java}\label{javathreads}
Schreiben Sie ein Programm in Java, welches acht Threads erstellt und startet. Jeder Thread soll dabei "`Hello World from Thread i"' mit i als Index des Threads im Array ausgeben. Beobachten und interpretieren Sie das Ergebnis.\\
\\
Lösung: \url{https://gist.github.com/lukaswerner/c1a53b8b03fe4d93e1e9dfcfc50c9cb5}

\subsection{Erzeugen von Threads in Java (Ohne Synchronisierung von Strings)}
Erweitern Sie das Programm aus \ref{javathreads} so, dass die Ausgabe des Strings "`Hello World from Thread i"' nicht synchronisiert erfolgt. Schreiben Sie dafür eine Methode, welche einen String Zeichen für Zeichen ausgibt, rufen Sie diese Methode anstelle von System.out.println() auf.\\
\\
Lösung: \url{https://gist.github.com/lukaswerner/61a25246aca3c9fc3fa7c57d86f42af5}

\subsection{Race Condition Beispiel}\label{racecondition}
Schreiben Sie ein Programm in Java, welches $ \geq 10000 $ Threads startet. Jeder Thread soll dabei eine statische Variable (z.B. \emph{z}) hochzählen mit dem \emph{++}-Operator. Geben Sie am Ende diese statische Variable aus und beobachten, sowie interpretieren das Ergebnis.\\
\\
Lösung: \url{https://gist.github.com/lukaswerner/32e344a4c1febc69724d08a60c56064c}

\subsection{Race Condition Lösung}
Erweitern Sie das Programm aus \ref{racecondition} so, dass die Race Condition nicht stattfindet. Implementieren Sie hierfür eine Methode, die gesperrt wird, sobald ein Thread sie ausführt (Stichwort: \emph{synchronized}). Diese Methode soll dann \emph{z++} ausführen.\\
\\
Lösung: \url{https://gist.github.com/lukaswerner/12825318f45e55ec2f3f502a0a49584a}

\section{Amdahls Gesetz}

\paragraph{a)} Finden Sie heraus, welcher Anteil der Zähler-Aufgabe mit $ k = 10000 $ Threads parallelisierbar ist.

\subsubsection*{Lösung}
$ a := $ Zeit bei sequentiellem Ablauf\\
$ b := $ Zeit bei parallelem Ablauf
\begin{align*}
&{} & b & = a \left(1 - p + \frac{p}{n}\right)\\
&\Leftrightarrow & \frac{b}{a} & = 1 - p + \frac{p}{n}\\
&\Leftrightarrow & \frac{b}{a} - 1 & = \frac{p}{n} - p = p \left(\frac{1}{n} -1\right)\\
&\Leftrightarrow & \frac{\frac{b}{a} - 1}{\frac{1}{n} -1} & = p\\
&\Leftrightarrow & p & = \frac{n \left(\frac{b}{a} - 1\right)}{n \left(\frac{1}{n} - 1\right)} = \frac{n \left(\frac{b}{a} - 1\right)}{1 - n} = \frac{n a \left(\frac{b}{a} - 1\right)}{a \left(1 - n\right)} = \frac{n \left(b - a\right)}{a \left(1 - n\right)}
\end{align*}
\noindent
Testwerte:\\
$ a = 0,0000588089s $\\
$ b = 0,6387376938s $\\
\begin{align*}
p = \frac{n \left(b - a\right)}{a \left(1 - n\right)} = \frac{10000 \left(0,6387376938s - 0,0000588089s\right)}{0,0000588089s \left(1 - 10000\right)} = -10861,3281... \approx -1086132,8 \%
\end{align*}

\paragraph{Mit Parallelisierung erheblich langsamer!}

\paragraph{b)} Welchen Anteil erwarten Sie für $ k = 20000 $ Threads?

Zurück gestellt...

\paragraph{c)} Wie weit kann man die Bearbeitung durch Parallelisierung beschleunigen, wenn man beliebig viele Prozessoren zur Verfügung hat?

\begin{align*}
\lim\limits_{n \to \infty} \frac{1}{1 - p + \frac{p}{n}} = \frac{1}{1 - p} = \frac{1}{1 - \frac{n \left(b - a\right)}{a \left(1 - n\right)}} = \ ?
\end{align*}

\section{Verschränkung (1)}

Thread $ p $ habe $ m $ Schritte, Thread $ q $ habe $ n $ Schritte auszuführen.

\paragraph{a)} Geben Sie eine rekursive Definition für die Anzahl $ \anz(m, n) $ der möglichen verschränkten Abläufe von $ p $ und $ q $ an.

% TODO: Evtl. noch Visualisierung

\subsubsection*{Lösung}
\begin{equation*}
\anz(m, n) = 
\begin{cases}
1 & m = 0 \vee n = 0\\
\anz(m - 1, n) + anz(m, n - 1) & \text{sonst}
\end{cases}
\end{equation*}

\paragraph{b)} Finden Sie einen geschlossenen Ausdruck für $ \anz(m, n) $.

\subsubsection*{Lösung}
Wegbeschreibung ist ein Bitvektor mit $ m $ Nullen und $ n $ Einsen, wobei hier gilt:
\begin{center}
$ 0 \ \widehat{=} $ Schritt nach rechts\\
$ 1 \ \widehat{=} $ Schritt nach unten
\end{center}
Die Länge des Bitvektors ist $ n + m $. Isomorph zum Bitvektor mit $ m $ Nullen und $ n $ Einsen sind $ n $ Teilmengen einer $ n + m $ Menge.\\
\\
Beispiel:\\
Bitvektor: $ 011010 $, % TODO: Markieren in Grafik
$ (m + n) $-Menge sei $ \{1, ..., m + n\} $,
dargestellte Teilmente ist $ \{2, 3, 5\} $

\begin{center}
Satz: Die Anzahl der $ k $ Teilmengen einer $ n $-Menge ist $ \binom{n}{k} $.
\end{center} 

Behauptung: $ \anz(m, n) = \binom{m + n}{n} $

\begin{proof}
\begin{align*}
& \text{IA} &  & \text{Sei } n = 0 \Rightarrow \anz(m, 0) = 1 = \binom{m}{0}\\
& \text{IV} &  & \text{Für ein festes } k = m + n \text{ gilt: } \anz(m, n) = \binom{m + n}{n}.\\
& \text{IS} &  & \text{Annahme: } m + n = k + 1\\
& {} &  & \anz(m, n) = \anz(m - 1, n) + \anz(m, n - 1) \overset{\text{IV}}{=} \binom{m - 1 + n}{n} + \binom{m + n - 1}{n - 1}\\
& {} &  & = \binom{k}{n} + \binom{k}{n - 1} \overset{\text{def.}}{=} \binom{k + 1}{n}
\end{align*}
\end{proof}

\paragraph{c)} Schätzen Sie die Größenordnung von $ \anz(m, n) $.

(Korrektur):\\
Behauptung: $ \anz(n,n) \geq 2^n - 1$

\begin{proof}
\begin{align*}
& \text{1. } n = 1: \anz(n,n) = \binom{2}{1} = 2 \\
& \text{2. } n > 1: \anz(n,n) = \binom{2n}{1} = \binom{2n-1}{n} + \binom{2n-1}{n-1}\\
& 2^n = 2 * 2^{n-1 } \overset{\text{IV}}{\leq} 2 * \binom{2(n-2)}{n-1} \leq \binom{2n-1}{n} + \binom{2n-1}{n-1}\\
& \text{weil } \binom{2n-1}{n-1} \geq \binom{2n-2}{n-1} \text{ und } \binom{2n-1}{n} \geq \binom{2n-2}{n-1} \\
& \binom{2n-1}{n-1} = \binom{2n-2}{n-1} + \binom{2n-2}{n-2}
\end{align*}
\end{proof}

\section{Verschränkung (2)}

$n $ Threads sollen verschränkt zueinander laufen. Jeder Thread habe $ 2 $ Schritte auszuführen.

\paragraph{a)} Geben Sie eine rekursive Definition an für die Anzahl $ \anz^*(n) $ der möglochen Abläufe.

\subsubsection*{Lösung}
Es gilt $ \anz^*(1) = 1 $. Sei nun $ n > 1 $.\\
Nach IV liefert $ \anz^*(n - 1) $ die Anzahl der möglichen Abläufe für $ n - 1 $ Threads.\\

% TODO: evtl. Zeichnung für Schritte der n - 1 Threads mit (2(n-1) Schritte)
%       Teil der Zeichnung: $(2(n - 1)) - 1$ Möglichkeiten für den letzten Thread seinen ersten Schritt zu plazieren.

% TODO: zweite Zeichnung: aus dieser geht hervor dass die Positionen aus einer Fläche mit  $ \frac{(2n-1)*(2n-2)}{2} $ hervorgeht

Also gilt:\\
\begin{equation*}
\anz^*(n) = 
\begin{cases}
1 & \text{falls } n = 1\\
\anz(n - 1) (2n - 1) (n - 1) & \text{sonst}
\end{cases}
\end{equation*}



\paragraph{b)} Finden Sie einen geschlossenen Ausdruck für $ \anz^*(n) $.
\paragraph{c)} Schätzen Sie die Größenordnung von $ \anz^*(n) $.
b) sowie c) kann auch Prof. Geser nicht lösen, wächst aber in etwa im Quadrat der Fakultät


\section{zeitliche Abläufe}

\paragraph{a)} Geben Sie zu dem folgenden zeitlichen Ablauf den passenden seriellen Ablauf (= Aktionsfolge) an:
$ \{(a, 5.3), (b, 3.7), (c, 3.2), (a, 1.7), (a, 2.1), (b, 2.5)\}$

\subsubsection*{Lösung}
\begin{equation*}
\ f(x) = 
\begin{cases}
a & \text{falls } x \in {1, 2, 6}\\
b & \text{falls } x \in {3, 5}\\
c & \text{sonst}
\end{cases}
\end{equation*}

\paragraph{b)} Welche der folgenden Mengen von Ereignissen sind diskrete zeitliche Abläufe? Dazu sei $ A = \{a, b\} $.  

% TODO Lösungen eintragen
\subsubsection*{Lösung}

\paragraph{c)} Geben Sie zu jedem diskreten zeitlichen Ablauf $ E $ aus Teilaufgabe $ (b) $ die Ereignisse $E^1, E^2, E^3 $ an.

% TODO Lösungen eintragen
\subsubsection*{Lösung}

\section{Einigkeit}
Beweisen Sie, dass für alle Threads $ p_1 $, $ p_2 $ folgende Aussagen äquivalent sind:
\begin{align*}
& \alpha) \ \pi_{A_1 \cap A_2} \left(E_1 \cup E_2\right) = E_1 \cap E_2\\
& \beta) \ \pi_{A_1 \cap A_2} \left(E_1 \oplus E_2\right) = \emptyset\\
& \gamma) \ \pi_{A_1} \left(E_2\right) = \pi_{A_2} \left(E_1\right)
\end{align*}

Dabei sei $ A_i $ das Prozessalphabet von Thread $ p_i $ und $ E_i $ der zeitliche Ablauf von Thread $ p_i, i \in \{1, 2\}$.\\
Voraussetzung: Für alle $ e \in E_i $ gilt $ aktion(e) \in A_i, i \in \{1, 2\} $.\\
Dann gilt: $ \pi_{A_i} \left(E_i\right) = E_i $\\

\subsubsection*{Lösung}

zz. $\beta \Rightarrow \alpha$\\
\begin{proof}
\begin{align*}
	& \pi_{A_1 \cap A_2}\left(E_1 \cup E_2\right) = \\
    & \pi_{A_1 \cap A_2}\left(\left(E_1 \oplus E_2\right) \cup \left(E_1 \cap E_2\right)\right) = \\
	& \pi_{A_1 \cap A_2}\left(E_1 \oplus E_2\right) \cup \pi_{A_1 \cap A_2}\left(E_1 \cap E_2\right) = \\
	& \emptyset \cup \pi_{A_1 \cap A_2}\left(E_1 \cap E_2\right) =\\
	& \pi_{A_1}\left(\pi_{A_2}\left(E_1 \cap E_2\right)\right) = \\
	& \pi_{A_1}\left(E_1 \cap E_2\right) =
	E_1 \cap E_2
\end{align*} 
\end{proof}

zz. $\alpha \Rightarrow \beta$\\
\begin{proof}
	\begin{align*}
		& \pi_{A_1 \cap A_2}\left(E_1 \oplus E_2\right) = \\
		& \pi_{A_1 \cap A_2}\left(\left(E_1 \cup E_2\right) \setminus \left(E_1 \cap E_2\right)\right) = \\
		& \pi_{A_1 \cap A_2} \left(E_1 \cup E_2\right) \setminus \pi_{A_1 \cap A_2} \left(E_1 \cap E_2\right) \overset{\alpha}{=} \\
		& \left(E_1 \cap E_2\right) \setminus \left(E_1 \cap E_2\right) = \emptyset
	\end{align*}
\end{proof}

zz. $\beta \Rightarrow \gamma$
\begin{proof}
	\begin{align*}
		& (1) \pi_{A_1}\left(E_2\right) \setminus \pi_{A_2}\left(E_1\right) = \emptyset \iff \pi_{A_1}\left(E_2\right) \subseteq \pi_{A_2}\left(E_1\right) \\
		& (2) \pi_{A_2}\left(E_1\right) \setminus \pi_{A_1}\left(E_2\right) = \emptyset \iff \pi_{A_2}\left(E_1\right) \subseteq \pi_{A_1}\left(E_2\right) \\ \\
		& (1) \wedge (2) \\
		& \iff \pi_{A_1}\left(E_2\right) \setminus \pi_{A_2}\left(E_1\right) \cup \pi_{A_2}\left(E_1\right) \setminus \pi_{A_1}\left(E_2\right) = \emptyset \\
		& \iff \pi_{A_2}\left(E_2\right) \oplus \pi_{A_2}\left(E_1\right) = \emptyset \\ \\
		& zz. \pi_{A_1 \cap A_2}\left(E_1 \oplus E_2\right) = \pi_{A_1}\left(E_2\right) \oplus \pi_{A_2}\left(E_1\right) \\
		& \pi_{A_1 \cap A_2}\left(E_1 \oplus E_2\right) = \pi_{A_1}\left(\pi_{A_2}\left(E_1 \oplus E_2\right)\right) = \\
		& \pi_{A_1}\left(\pi_{A_2}\left(E_1\right) \oplus E_2\right) = \pi_{A_1}\left(E_2\right) \oplus \pi_{A_1}\left(\pi_{A_2}\left(E_1\right)\right) = \\
		& \pi_{A_2}\left(E_1\right) \oplus \pi_{A_1}\left(\pi_{A_1}\left(E_1\right)\right) = \\
		& \pi_{A_2}\left(E_1\right) \oplus \pi_{A_1}\left(E_2\right)
	\end{align*}
\end{proof}

zz. $\gamma \Rightarrow \beta$
\begin{proof}
	\begin{align*}
		& \pi_{A_1 \cap A_2}\left(E_1 \oplus E_2\right) = \pi_{A_1}\left(\pi_{A_2}\left(E_1 \oplus E_2\right)\right) = \\
		& \pi_{A_1}\left(\pi_{A_2}\left(E_1\right) \oplus E_2\right) = \pi_{A_1}\left(\pi_{A_1}\left(E_2\right) \oplus E_2\right) \overset{\gamma}{=} \\
		& \pi_{A_1}\left(E_2\right) \oplus \pi_{A_1}\left(E_2\right) = \emptyset
	\end{align*}
\end{proof}

\subsection{Aufgabe:}
\paragraph{a)} Beweisen Sie, dass \glqq $\rightarrow$\grqq{} eine Wohlordnung (irreflexiv, transitiv, total, fundiert) ist.

\subsection{Lösung}
\paragraph{$\rightarrow$ irreflexiv} Beweis durch Wiederspruch\\
Annahme: e $\rightarrow$ e gilt. Nach Definition von \glqq $\rightarrow$\grqq{} gilt zeit(e) < zeit(e).\\ Widerspruch zu < irreflexiv. 

\paragraph{$\rightarrow$ transitiv}
a $\rightarrow$ b und b $\rightarrow$ c, dann a $\rightarrow$ c\\
zeit(a) < zeit(b) und zeit(b) < zeit(c)\\
$\Rightarrow$ zeit(a) < zeit(b) < zeit(c) $\iff$ zeit(a) < zeit(c)\\ 
$\Rightarrow$ a $\rightarrow$ c, wegen Transitivität <

\paragraph{$\rightarrow$ total}
Für Ereignisse $e_1 \neq e_2$ gilt $e_1 \rightarrow e_2$ oder $e_2 \rightarrow e_1$ \\
Seien $e_1, e_2; e_1 \neq e_2$ Ereignisse\\
Dann zeit($e_1$) < zeit($e_2$) oder zeit($e_2$) < zeit($e_1$) oder zeit($e_1$) = zeit($e_2$)\\
\glqq <\grqq{} ist total.\\
Wenn zeit($e_1$) = zeit($e_2$), dann $e_1 = e_2$ nach Vorraussetzung (idealisierende Annahme 3). Widerspruch zu $e_1 \neq e_2$. Also entweder zeit($e_1$) < zeit($e_2$) damit $e_1 \rightarrow e_2$ oder zeit($e_2$) < zeit($e_1$) damit $e_2 \rightarrow e_1$.

\paragraph{$\rightarrow$ fundiert}
zz. gibt keine unendliche \glqq $\leftarrow$\grqq-Kette. Beweis durch Widerspruch.\\
Annahme: $\left(e_i\right)_{i \in \mathbb{N}}$ sei unendliche \glqq $\leftarrow$\grqq-Kette. \\
Damit $e_i \leftarrow e_{i + 1}$ für alle $i \in \mathbb{N}$. \\
Damit zeit($e_i$) > zeit($e_{i + 1}$) für alle $i \in \mathbb{N}$ wegen Definition von $\rightarrow$. \\
Damit ist $\left(zeit\left(e_i\right)\right)_{i \in \mathbb{N}}$ eine unendliche  \glqq $\leftarrow$\grqq-Kette. \\
Widerspruch zu: < ist fundiert auf $\mathbb{N}$.
\end{document}